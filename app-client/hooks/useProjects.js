import { useState, useEffect, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import { apiUrl } from '@config/api.js';
import { PROJECT_STATES, PROJECT_ACTIONS, MESSAGE_TYPES } from '@config/constants.js';

export function useProjects() {
  const navigate = useNavigate();
  const hasLoadedOnce = useRef(false);
  
  const [projects, setProjects] = useState([]);
  const [loading, setLoading] = useState(true);
  const [consoleMessages, setConsoleMessages] = useState([]);
  const [actionLoading, setActionLoading] = useState({});
  const [showCreateModal, setShowCreateModal] = useState(false);
  const [filterState, setFilterState] = useState(null);
  const [showConfirmModal, setShowConfirmModal] = useState(false);
  const [projectToDelete, setProjectToDelete] = useState(null);

  // Charger les projets au montage
  useEffect(() => {
    if (!hasLoadedOnce.current) {
      loadProjects();
      hasLoadedOnce.current = true;
    }
  }, []);

  const addConsoleMessage = (type, text) => {
    console.log('üìù ADD MESSAGE:', type, text);
    const message = {
      type,
      text,
      timestamp: new Date().toISOString()
    };
    setConsoleMessages(prev => {
      console.log('üìù CONSOLE MESSAGES LENGTH:', prev.length, '‚Üí', prev.length + 1);
      return [...prev, message];
    });
  };

  const clearConsole = () => {
    console.log('üóëÔ∏è CLEAR CONSOLE');
    setConsoleMessages([]);
  };

  const updateProjectState = (projectId, newState) => {
    console.log('üîÑ OPTIMISTIC UPDATE:', projectId, '‚Üí', newState);
    setProjects(prev => 
      prev.map(project => 
        project.id === projectId 
          ? { ...project, state: newState }
          : project
      )
    );
  };

  const getFilteredProjects = () => {
    let filtered = projects;
    
    if (filterState) {
      filtered = projects.filter(project => project.state === filterState);
      console.log('üîç FILTER BY STATE:', filterState, '‚Üí', filtered.length, 'projets');
    }
    
    return filtered.sort((a, b) => new Date(b.created) - new Date(a.created));
  };

  const handleStateFilter = (state) => {
    console.log('üîç FILTER CHANGED:', filterState, '‚Üí', state);
    setFilterState(state);
    if (state) {
      addConsoleMessage(MESSAGE_TYPES.INFO, `Filtrage par √©tat: ${state}`);
    } else {
      addConsoleMessage(MESSAGE_TYPES.INFO, 'Affichage de tous les projets');
    }
  };

  const loadProjects = async (silent = false) => {
    setLoading(true);
    console.log('üìÇ LOAD PROJECTS START, silent:', silent);
    
    try {
      console.log('Chargement des projets...');
      const response = await fetch(apiUrl('projects'));
      
      if (!response.ok) {
        throw new Error(`Erreur HTTP: ${response.status}`);
      }
      
      const data = await response.json();
      
      if (data.success) {
        console.log('üìÇ PROJECTS LOADED:', data.projects.length);
        const sortedProjects = data.projects.sort((a, b) => new Date(b.created) - new Date(a.created));
        setProjects(sortedProjects);
        console.log(`${data.projects.length} projets charg√©s`);
        if (!silent) {
          addConsoleMessage(MESSAGE_TYPES.INFO, `Dashboard initialis√© - ${data.projects.length} projets`);
        }
      } else {
        throw new Error(data.error || 'Erreur lors du chargement');
      }
    } catch (error) {
      console.error('Erreur loadProjects:', error);
      addConsoleMessage(MESSAGE_TYPES.ERROR, `Impossible de charger les projets: ${error.message}`);
    } finally {
      console.log('üìÇ LOAD PROJECTS END');
      setLoading(false);
    }
  };

  const handleNewProject = () => {
    console.log('Ouverture modal cr√©ation');
    setShowCreateModal(true);
  };

  const handleCloseModal = () => {
    console.log('Fermeture modal');
    setShowCreateModal(false);
  };

  const handleCreateProject = async (formData) => {
    console.log('Cr√©ation projet via API:', formData);
    
    try {
      const response = await fetch(apiUrl('projects'), {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          projectId: formData.projectId,
          config: {
            name: formData.name,
            template: formData.template
          }
        }),
      });

      if (!response.ok) {
        throw new Error(`Erreur HTTP: ${response.status}`);
      }

      const data = await response.json();
      
      if (data.success) {
        console.log('Projet cr√©√© avec succ√®s:', data.message);
        addConsoleMessage(MESSAGE_TYPES.SUCCESS, `Projet "${formData.name}" cr√©√© avec succ√®s`);
        await loadProjects(true);
      } else {
        throw new Error(data.error || 'Erreur lors de la cr√©ation');
      }
    } catch (error) {
      console.error('Erreur cr√©ation:', error);
      addConsoleMessage(MESSAGE_TYPES.ERROR, `Cr√©ation √©chou√©e: ${error.message}`);
      throw new Error(`Cr√©ation √©chou√©e: ${error.message}`);
    }
  };

  const handleDeleteRequest = (projectId, projectName) => {
    console.log('üóëÔ∏è DELETE REQUEST for:', projectId);
    setProjectToDelete({ id: projectId, name: projectName });
    setShowConfirmModal(true);
  };

  const handleCancelDelete = () => {
    console.log('‚ùå DELETE CANCELLED');
    setShowConfirmModal(false);
    setProjectToDelete(null);
  };

  const handleConfirmDelete = async () => {
    if (!projectToDelete) return;
    
    console.log('üíÄ DELETE CONFIRMED for:', projectToDelete.id);
    setShowConfirmModal(false);
    
    await handleProjectAction(projectToDelete.id, PROJECT_ACTIONS.DELETE);
    
    setProjectToDelete(null);
  };

  const executeDeleteAction = async (projectId) => {
    console.log('üóëÔ∏è EXECUTING DELETE for:', projectId);
    
    try {
      const response = await fetch(apiUrl(`projects/${projectId}`), {
        method: 'DELETE',
      });

      if (!response.ok) {
        throw new Error(`Erreur HTTP: ${response.status}`);
      }

      const data = await response.json();
      
      if (data.success) {
        console.log('Suppression r√©ussie:', data.message);
        addConsoleMessage(MESSAGE_TYPES.SUCCESS, `Projet ${projectId} supprim√©`);
        setProjects(prev => prev.filter(p => p.id !== projectId));
      } else {
        throw new Error(data.error || 'Erreur lors de la suppression');
      }
    } catch (error) {
      console.error('Erreur DELETE:', error);
      addConsoleMessage(MESSAGE_TYPES.ERROR, `Suppression √©chou√©e: ${error.message}`);
    }
  };

  const handleProjectAction = async (projectId, action) => {
    console.log('üîÑ START ACTION:', action, 'sur', projectId);
    
    const actionKey = `${projectId}-${action}`;
    console.log('‚è≥ SET LOADING TRUE pour:', actionKey);
    setActionLoading(prev => {
      if (prev[actionKey] === true) {
        console.log('‚è≥ SKIP SET LOADING - d√©j√† true');
        return prev;
      }
      const newState = { ...prev, [actionKey]: true };
      console.log('‚è≥ ACTION LOADING STATE:', newState);
      return newState;
    });
    
    try {
      if (action === PROJECT_ACTIONS.EDIT) {
        console.log(`Navigation vers √©diteur pour projet DRAFT: ${projectId}`);
        addConsoleMessage(MESSAGE_TYPES.INFO, `Ouverture √©diteur pour projet ${projectId}`);
        navigate(`/editor/${projectId}`);
        return;
      }
      
      if (action === PROJECT_ACTIONS.REVERT) {
        console.log(`Revert projet ${projectId}`);
        
        const response = await fetch(apiUrl(`projects/${projectId}/revert`), {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
        });

        if (!response.ok) {
          throw new Error(`Erreur revert HTTP: ${response.status}`);
        }

        const data = await response.json();
        
        if (data.success) {
          console.log('Revert r√©ussi:', data.message);
          addConsoleMessage(MESSAGE_TYPES.SUCCESS, `Projet ${projectId} remis en DRAFT`);
          updateProjectState(projectId, PROJECT_STATES.DRAFT);
        } else {
          throw new Error(data.error || 'Erreur lors du revert');
        }
        return;
      }

      if (action === PROJECT_ACTIONS.UPDATE) {
        console.log(`Simulation blue-green deployment pour projet ${projectId}`);
        addConsoleMessage(MESSAGE_TYPES.INFO, `D√©marrage mise √† jour blue-green pour ${projectId}`);
        
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        console.log('Update blue-green simul√© avec succ√®s');
        addConsoleMessage(MESSAGE_TYPES.SUCCESS, `Mise √† jour blue-green termin√©e pour ${projectId}`);
      }

      if (action === PROJECT_ACTIONS.DEPLOY) {
        const response = await fetch(apiUrl(`projects/${projectId}/deploy`), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
        });

        if (!response.ok) {
          throw new Error(`Erreur HTTP: ${response.status}`);
        }

        const data = await response.json();
        
        if (data.success) {
          console.log('Deploy r√©ussi:', data.message);
          addConsoleMessage(MESSAGE_TYPES.SUCCESS, `Projet ${projectId} d√©ploy√© avec succ√®s`);
          updateProjectState(projectId, PROJECT_STATES.OFFLINE);
        } else {
          throw new Error(data.error || 'Erreur lors du deploy');
        }
      }

      if (action === PROJECT_ACTIONS.START) {
        const response = await fetch(apiUrl(`projects/${projectId}/start`), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
        });

        if (!response.ok) {
          throw new Error(`Erreur HTTP: ${response.status}`);
        }

        const data = await response.json();
        
        if (data.success) {
          console.log('Start r√©ussi:', data.message);
          addConsoleMessage(MESSAGE_TYPES.SUCCESS, `Services ${projectId} d√©marr√©s`);
          updateProjectState(projectId, PROJECT_STATES.ONLINE);
        } else {
          throw new Error(data.error || 'Erreur lors du start');
        }
      }

      if (action === PROJECT_ACTIONS.STOP) {
        const response = await fetch(apiUrl(`projects/${projectId}/stop`), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
        });

        if (!response.ok) {
          throw new Error(`Erreur HTTP: ${response.status}`);
        }

        const data = await response.json();
        
        if (data.success) {
          console.log('Stop r√©ussi:', data.message);
          addConsoleMessage(MESSAGE_TYPES.SUCCESS, `Services ${projectId} arr√™t√©s`);
          updateProjectState(projectId, PROJECT_STATES.OFFLINE);
        } else {
          throw new Error(data.error || 'Erreur lors du stop');
        }
      }
      
      if (action === PROJECT_ACTIONS.BUILD) {
        const response = await fetch(apiUrl(`projects/${projectId}/build`), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
        });

        if (!response.ok) {
          throw new Error(`Erreur HTTP: ${response.status}`);
        }

        const data = await response.json();
        
        if (data.success) {
          console.log('Build r√©ussi:', data.message);
          addConsoleMessage(MESSAGE_TYPES.SUCCESS, `Projet ${projectId} compil√© avec succ√®s`);
          updateProjectState(projectId, PROJECT_STATES.BUILT);
        } else {
          throw new Error(data.error || 'Erreur lors du build');
        }
      }
      
      if (action === PROJECT_ACTIONS.DELETE) {
        await executeDeleteAction(projectId);
        return;
      }
      
    } catch (error) {
      console.error(`Erreur action ${action}:`, error);
      addConsoleMessage(MESSAGE_TYPES.ERROR, `${action} √©chou√©: ${error.message}`);
    } finally {
      console.log('‚úÖ SET LOADING FALSE pour:', actionKey);
      setActionLoading(prev => {
        if (prev[actionKey] === false) {
          console.log('‚úÖ SKIP SET LOADING - d√©j√† false');
          return prev;
        }
        const newState = { ...prev, [actionKey]: false };
        console.log('‚úÖ ACTION LOADING FINAL STATE:', newState);
        return newState;
      });
      console.log('üîÑ END ACTION:', action, 'sur', projectId);
    }
  };

  return {
    projects: getFilteredProjects(),
    allProjects: projects,
    loading,
    consoleMessages,
    actionLoading,
    showCreateModal,
    filterState,
    showConfirmModal,
    projectToDelete,
    // FONCTIONS MANQUANTES AJOUT√âES
    handleNewProject,
    handleCloseModal,
    handleCreateProject,
    handleProjectAction,
    handleStateFilter,
    handleDeleteRequest,
    handleCancelDelete,
    handleConfirmDelete,
    clearConsole,
    loadProjects
  };
}
