import { useState, useEffect, useRef } from 'react';
import { useNavigate } from 'react-router-dom';

export function useProjectActions() {
  const navigate = useNavigate();
  const hasLoadedOnce = useRef(false);
  
  const [projects, setProjects] = useState([]);
  const [loading, setLoading] = useState(true);
  const [consoleMessages, setConsoleMessages] = useState([]);
  const [actionLoading, setActionLoading] = useState({});
  const [showCreateModal, setShowCreateModal] = useState(false);
  const [filterState, setFilterState] = useState(null); // null = tous, 'DRAFT' = seulement DRAFT, etc.

  // Charger les projets au montage
  useEffect(() => {
    if (!hasLoadedOnce.current) {
      loadProjects();
      hasLoadedOnce.current = true;
    }
  }, []);

  const addConsoleMessage = (type, text) => {
    console.log('üìù ADD MESSAGE:', type, text);
    const message = {
      type, // 'error', 'success', 'info'
      text,
      timestamp: new Date().toISOString()
    };
    setConsoleMessages(prev => {
      console.log('üìù CONSOLE MESSAGES LENGTH:', prev.length, '‚Üí', prev.length + 1);
      return [...prev, message];
    });
  };

  const clearConsole = () => {
    console.log('üóëÔ∏è CLEAR CONSOLE');
    setConsoleMessages([]);
  };

  // Fonction pour update optimistic d'un projet
  const updateProjectState = (projectId, newState) => {
    console.log('üîÑ OPTIMISTIC UPDATE:', projectId, '‚Üí', newState);
    setProjects(prev => 
      prev.map(project => 
        project.id === projectId 
          ? { ...project, state: newState }
          : project
      )
    );
  };

  // Fonction pour filtrer/trier les projets
  const getFilteredProjects = () => {
    let filtered = projects;
    
    // Filtrage par √©tat si s√©lectionn√©
    if (filterState) {
      filtered = projects.filter(project => project.state === filterState);
      console.log('üîç FILTER BY STATE:', filterState, '‚Üí', filtered.length, 'projets');
    }
    
    // Toujours trier par date de cr√©ation (plus r√©cent en premier)
    return filtered.sort((a, b) => new Date(b.created) - new Date(a.created));
  };

  // Fonction pour changer le filtre d'√©tat
  const handleStateFilter = (state) => {
    console.log('üîç FILTER CHANGED:', filterState, '‚Üí', state);
    setFilterState(state);
    if (state) {
      addConsoleMessage('info', `Filtrage par √©tat: ${state}`);
    } else {
      addConsoleMessage('info', 'Affichage de tous les projets');
    }
  };

  const loadProjects = async (silent = false) => {
    setLoading(true);
    console.log('üìÇ LOAD PROJECTS START, silent:', silent);
    
    try {
      console.log('Chargement des projets...');
      const response = await fetch('http://localhost:3000/projects');
      
      if (!response.ok) {
        throw new Error(`Erreur HTTP: ${response.status}`);
      }
      
      const data = await response.json();
      
      if (data.success) {
        console.log('üìÇ PROJECTS LOADED:', data.projects.length);
        // Tri par d√©faut : plus r√©cent en premier (created desc)
        const sortedProjects = data.projects.sort((a, b) => new Date(b.created) - new Date(a.created));
        setProjects(sortedProjects);
        console.log(`${data.projects.length} projets charg√©s`);
        // Messages diff√©renci√©s : initial vs reload
        if (!silent) {
          // Message pour chargement initial (depuis useEffect)
          addConsoleMessage('info', `Dashboard initialis√© - ${data.projects.length} projets`);
        }
        // Pas de message pour les reloads silencieux post-action
      } else {
        throw new Error(data.error || 'Erreur lors du chargement');
      }
    } catch (error) {
      console.error('Erreur loadProjects:', error);
      // Erreurs toujours affich√©es m√™me en mode silent
      addConsoleMessage('error', `Impossible de charger les projets: ${error.message}`);
    } finally {
      console.log('üìÇ LOAD PROJECTS END');
      setLoading(false);
    }
  };

  const handleNewProject = () => {
    console.log('Ouverture modal cr√©ation');
    setShowCreateModal(true);
  };

  const handleCloseModal = () => {
    console.log('Fermeture modal');
    setShowCreateModal(false);
  };

  const handleCreateProject = async (formData) => {
    console.log('Cr√©ation projet via API:', formData);
    
    try {
      const response = await fetch('http://localhost:3000/projects', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          projectId: formData.projectId,
          config: {
            name: formData.name,
            template: formData.template
          }
        }),
      });

      if (!response.ok) {
        throw new Error(`Erreur HTTP: ${response.status}`);
      }

      const data = await response.json();
      
      if (data.success) {
        console.log('Projet cr√©√© avec succ√®s:', data.message);
        addConsoleMessage('success', `Projet "${formData.name}" cr√©√© avec succ√®s`);
        // Recharger la liste des projets
        await loadProjects(true); // Silent reload
      } else {
        throw new Error(data.error || 'Erreur lors de la cr√©ation');
      }
    } catch (error) {
      console.error('Erreur cr√©ation:', error);
      addConsoleMessage('error', `Cr√©ation √©chou√©e: ${error.message}`);
      throw new Error(`Cr√©ation √©chou√©e: ${error.message}`);
    }
  };

  const handleProjectAction = async (projectId, action) => {
    console.log('üîÑ START ACTION:', action, 'sur', projectId);
    
    const actionKey = `${projectId}-${action}`;
    console.log('‚è≥ SET LOADING TRUE pour:', actionKey);
    setActionLoading(prev => {
      // √âviter nouvel objet si valeur identique
      if (prev[actionKey] === true) {
        console.log('‚è≥ SKIP SET LOADING - d√©j√† true');
        return prev;
      }
      const newState = { ...prev, [actionKey]: true };
      console.log('‚è≥ ACTION LOADING STATE:', newState);
      return newState;
    });
    
    try {
      if (action === 'EDIT') {
        // EDIT : navigation directe vers √©diteur (seulement si DRAFT)
        console.log(`Navigation vers √©diteur pour projet DRAFT: ${projectId}`);
        addConsoleMessage('info', `Ouverture √©diteur pour projet ${projectId}`);
        navigate(`/editor/${projectId}`);
        return;
      }
      
      if (action === 'REVERT') {
        // REVERT : nettoie le code g√©n√©r√© et passe en DRAFT, SANS redirection
        console.log(`Revert projet ${projectId}`);
        
        const response = await fetch(`http://localhost:3000/projects/${projectId}/revert`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
        });

        if (!response.ok) {
          throw new Error(`Erreur revert HTTP: ${response.status}`);
        }

        const data = await response.json();
        
        if (data.success) {
          console.log('Revert r√©ussi:', data.message);
          addConsoleMessage('success', `Projet ${projectId} remis en DRAFT`);
          // Update optimistic : changement imm√©diat state
          updateProjectState(projectId, 'DRAFT');
          // PAS de loadProjects - √©tat d√©j√† √† jour
        } else {
          throw new Error(data.error || 'Erreur lors du revert');
        }
        return;
      }

      if (action === 'UPDATE') {
        // UPDATE : simulation blue-green deployment (mock data)
        console.log(`Simulation blue-green deployment pour projet ${projectId}`);
        addConsoleMessage('info', `D√©marrage mise √† jour blue-green pour ${projectId}`);
        
        // Simuler temps de d√©ploiement
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        console.log('Update blue-green simul√© avec succ√®s');
        addConsoleMessage('success', `Mise √† jour blue-green termin√©e pour ${projectId}`);
        // Pas de changement d'√©tat pour UPDATE - reste identique
        // PAS de loadProjects - √©tat inchang√©
      }

      if (action === 'DEPLOY') {
        // DEPLOY : compile le projet BUILT vers OFFLINE
        const response = await fetch(`http://localhost:3000/projects/${projectId}/deploy`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
        });

        if (!response.ok) {
          throw new Error(`Erreur HTTP: ${response.status}`);
        }

        const data = await response.json();
        
        if (data.success) {
          console.log('Deploy r√©ussi:', data.message);
          addConsoleMessage('success', `Projet ${projectId} d√©ploy√© avec succ√®s`);
          // Update optimistic : BUILT ‚Üí OFFLINE
          updateProjectState(projectId, 'OFFLINE');
        } else {
          throw new Error(data.error || 'Erreur lors du deploy');
        }
      }

      if (action === 'START') {
        // START : d√©marre les services OFFLINE vers ONLINE
        const response = await fetch(`http://localhost:3000/projects/${projectId}/start`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
        });

        if (!response.ok) {
          throw new Error(`Erreur HTTP: ${response.status}`);
        }

        const data = await response.json();
        
        if (data.success) {
          console.log('Start r√©ussi:', data.message);
          addConsoleMessage('success', `Services ${projectId} d√©marr√©s`);
          // Update optimistic : OFFLINE ‚Üí ONLINE
          updateProjectState(projectId, 'ONLINE');
        } else {
          throw new Error(data.error || 'Erreur lors du start');
        }
      }

      if (action === 'STOP') {
        // STOP : arr√™te les services ONLINE vers OFFLINE
        const response = await fetch(`http://localhost:3000/projects/${projectId}/stop`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
        });

        if (!response.ok) {
          throw new Error(`Erreur HTTP: ${response.status}`);
        }

        const data = await response.json();
        
        if (data.success) {
          console.log('Stop r√©ussi:', data.message);
          addConsoleMessage('success', `Services ${projectId} arr√™t√©s`);
          // Update optimistic : ONLINE ‚Üí OFFLINE
          updateProjectState(projectId, 'OFFLINE');
        } else {
          throw new Error(data.error || 'Erreur lors du stop');
        }
      }
      
      if (action === 'BUILD') {
        // BUILD : compile le projet DRAFT vers BUILT
        const response = await fetch(`http://localhost:3000/projects/${projectId}/build`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
        });

        if (!response.ok) {
          throw new Error(`Erreur HTTP: ${response.status}`);
        }

        const data = await response.json();
        
        if (data.success) {
          console.log('Build r√©ussi:', data.message);
          addConsoleMessage('success', `Projet ${projectId} compil√© avec succ√®s`);
          // Update optimistic : DRAFT ‚Üí BUILT
          updateProjectState(projectId, 'BUILT');
        } else {
          throw new Error(data.error || 'Erreur lors du build');
        }
      }
      
      if (action === 'DELETE') {
        // DELETE : supprime compl√®tement le projet
        const response = await fetch(`http://localhost:3000/projects/${projectId}`, {
          method: 'DELETE',
        });

        if (!response.ok) {
          throw new Error(`Erreur HTTP: ${response.status}`);
        }

        const data = await response.json();
        
        if (data.success) {
          console.log('Suppression r√©ussie:', data.message);
          addConsoleMessage('success', `Projet ${projectId} supprim√©`);
          // Update optimistic : Remove projet de la liste
          setProjects(prev => prev.filter(p => p.id !== projectId));
        } else {
          throw new Error(data.error || 'Erreur lors de la suppression');
        }
      }
      
    } catch (error) {
      console.error(`Erreur action ${action}:`, error);
      addConsoleMessage('error', `${action} √©chou√©: ${error.message}`);
    } finally {
      console.log('‚úÖ SET LOADING FALSE pour:', actionKey);
      setActionLoading(prev => {
        // √âviter nouvel objet si valeur identique
        if (prev[actionKey] === false) {
          console.log('‚úÖ SKIP SET LOADING - d√©j√† false');
          return prev;
        }
        const newState = { ...prev, [actionKey]: false };
        console.log('‚úÖ ACTION LOADING FINAL STATE:', newState);
        return newState;
      });
      console.log('üîÑ END ACTION:', action, 'sur', projectId);
    }
  };

  return {
    projects: getFilteredProjects(), // Projets filtr√©s et tri√©s
    allProjects: projects, // Tous les projets pour stats
    loading,
    consoleMessages,
    actionLoading,
    showCreateModal,
    filterState,
    handleNewProject,
    handleCloseModal,
    handleCreateProject,
    handleProjectAction,
    handleStateFilter,
    clearConsole,
    loadProjects
  };
}